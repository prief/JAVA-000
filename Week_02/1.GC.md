# GC总结：

## 串行 GC
- 年轻代使用拷贝-复制，老年代使用标记-清除-整理
- 发生GC时，会暂停
- 内存越小，GC次数越多
## 并行 GC
- 年轻代使用拷贝-复制，老年代使用标记-清除-整理
- GC处理时，暂停业务处理，所有线程处理GC垃圾回收。平常运行时，所以线程都去处理业务。因此，吞吐量比较高。
- 内存越小，GC次数越多
## CMS GC
- 年轻代使用拷贝-复制，老年代使用标记-清除
- CMS默认GC线程数是1/4，并且老年代只清除，无整理。所以当GC发生时，吞吐量不如并行 GC
- CMS GC 6个阶段
1. 初始化标记 - 暂停GC
2. 并行标记
3. 并行预清理
4. 最终标记 - 暂停GC
5. 并行清理
6. 并行重置
- 因为无整理，并且CMS GC 6阶段 暂停时间短，所以延迟比较低
- 内存越小，GC次数越多
## G1 GC
- 不分代,使用 region(2048) 存储数据，分为：
1. Eden区 （标记-复制 算法）
2. 存活区
3. 老年区 (标记-复制-整理 算法)
- GC 3个阶段
1. (G1 Evacuation Pause) (young)
2. 类似 CMS GC 的 并发标记
3. (G1 Evacuation Pause) (mix)
- 使用 -XX:MaxGCPauseMills 参数可以控制 GC暂停时间